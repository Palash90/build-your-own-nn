<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Neural Network Demystified</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .active-dataset {
            background: #00441b !important;
            border-color: #fff !important;
            box-shadow: 0 0 10px var(--neon);
            color: #fff !important;
        }

        :root {
            --neon: #00ff41;
            --bg: #0a0a0a;
            --panel: #1a1a1a;
        }

        body {
            font-family: 'Consolas', monospace;
            background: var(--bg);
            color: var(--neon);
            padding: 20px;
            margin: 0;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1600px;
            margin: auto;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 8px;
            overflow: hidden;
        }

        .controls {
            grid-column: span 2;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            background: #111;
            padding: 20px;
            border: 1px solid var(--neon);
        }

        canvas {
            background: #000;
            width: 100%;
            height: 250px;
            border: 1px solid #222;
            margin-top: 10px;
        }

        input,
        select,
        button {
            background: #000;
            color: var(--neon);
            border: 1px solid var(--neon);
            padding: 8px;
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #003311;
        }

        /* Weight Grid Styling */
        #weightInspector {
            grid-column: span 2;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.75rem;
        }

        .matrix-table {
            border-collapse: collapse;
            margin: 10px;
            display: inline-block;
            vertical-align: top;
            border: 1px solid #444;
        }

        .matrix-table td {
            border: 1px solid #333;
            padding: 4px;
            text-align: center;
            min-width: 60px;
        }

        .layer-title {
            color: #fff;
            text-transform: uppercase;
            font-size: 0.8rem;
            border-bottom: 1px solid var(--neon);
            margin-bottom: 5px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
        }

        label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }
    </style>
</head>

<body>

    <h2 style="text-align: center;">NEURAL ARCHITECT & TRACE ENGINE</h2>

    <div class="dashboard">
        <div class="controls">
            <div>
                <label>Data Management</label>
                <input id="inputX" value="0,0; 0,1; 1,0; 1,1">
                <input id="inputY" value="1; 0; 0; 1">
                <div class="btn-group">
                    <button onclick="setDataset('XOR', this)">XOR</button>
                    <button onclick="setDataset('XNOR', this)">XNOR</button>
                    <button onclick="setDataset('XOR3', this)">3 Input XOR</button>
                    <button onclick="setDataset('XNOR3', this)">3 Input XNOR</button>
                    <button onclick="setDataset('SIN', this)">SIN</button>
                    <button onclick="setDataset('COS', this)">COS</button>
                    <button onclick="setDataset('MOON', this)">MOONS</button>
                    <button onclick="setColorDataset(this)">Color Data Set</button>
                </div>

                <br />

                <div>
                    <label>Model Inference & Live Test</label>
                    <div id="dynamicTestUI"
                        style="background: #111; padding: 10px; border: 1px solid #333; margin-top: 5px; min-height: 80px;">
                    </div>
                    <div id="predictionResult" style="margin-top: 10px; font-size: 0.85rem;">
                        Result: awaiting input...
                    </div>
                </div>
            </div>

            <div>
                <label>Network Structure</label>
                <div id="layersConfig">
                    <div style="display:flex; gap:2px">
                        <input type="number" class="l-size" value="4">
                        <select class="l-act">
                            <option value="tanh">Tanh</option>
                            <option value="relu">ReLU</option>
                            <option value="lrelu">Leaky ReLU</option>
                        </select>
                    </div>
                </div>
                <button onclick="addLayerUI()">+ ADD LAYER</button>
                <button onclick="buildNetwork()" style="background: #222;">BUILD NETWORK</button>
                <div style="margin-top: 10px; border-top: 1px solid #444; pt: 5px;">
                    <label>Output Layer Activation</label>
                    <select id="outputAct">
                        <option value="sigmoid">Sigmoid (Classification 0-1)</option>
                        <option value="softmax">Softmax (Multi-class)</option>
                        <option value="linear">Regression (Linear)</option>
                    </select>
                </div>
            </div>

            <div>
                <label>Training Parameters</label>
                <div style="display:flex; gap:5px">
                    <div style="flex:1"><label>Epochs</label><input type="number" id="epochs" value="2000"></div>
                    <div style="flex:1"><label>Delay(ms)</label><input type="number" id="delay" value="10"></div>
                </div>
                <label>Learning Rate</label>
                <input type="number" id="lr" value="0.1" step="0.01">
            </div>

            <div>
                <label>Execution</label>
                <select id="plotMode">
                    <option value="auto">Auto (Adaptive)</option>
                    <option value="pca">Force PCA</option>
                    <option value="2d">Force 2D</option>
                </select>
                <button id="trainBtn" onclick="toggleTraining()"
                    style="background:#00441b; font-size: 1.1rem; height: 60px;">START TRAINING</button>
                <div class="btn-group">
                    <button onclick="stopFlag=true" style="background:#440000">STOP</button>
                    <button id="pauseBtn" onclick="togglePause()">PAUSE</button>
                </div>
                <div id="status" style="margin-top:10px;">Status: Awaiting Initialization</div>
            </div>
        </div>
        <div class="panel"><label>Prediction Plot</label>
            <div id="plot" style="height: 350px;"></div>
        </div>
        <div class="panel"><label>Loss History</label>
            <div id="lossPlot" style="height: 350px;"></div>



        </div>


        <div class="panel" style="grid-column: span 2;">
            <label>Topology & Weight Magnitude (Live)</label>
            <canvas id="netCanvas"></canvas>

        </div>

        <div id="weightInspector" class="panel">
            <label>Numerical Weight & Bias Matrices (Trace)</label>
            <div id="matrixDisplay"></div>
        </div>



    </div>

    <script>
        let layers = [], isTraining = false, isPaused = false, stopFlag = false, lossHistory = [];

        const Act = {
            relu: { f: x => Math.max(0, x), df: x => x > 0 ? 1 : 0 },
            tanh: { f: x => Math.tanh(x), df: x => 1 - Math.pow(Math.tanh(x), 2) },
            sigmoid: { f: x => 1 / (1 + Math.exp(-x)), df: x => { let s = 1 / (1 + Math.exp(-x)); return s * (1 - s); } },
            lrelu: { f: x => x > 0 ? x : 0.01 * x, df: x => x > 0 ? 1 : 0.01 },
            softmax: {
                // Softmax is applied to a whole row (array)
                f: (arr) => {
                    const max = Math.max(...arr); // For numerical stability
                    const exps = arr.map(v => Math.exp(v - max));
                    const sum = exps.reduce((a, b) => a + b);
                    return exps.map(v => v / sum);
                },
                df: x => 1
            },
            linear: { f: x => x, df: x => 1 }
        };

        class Layer {
            constructor(inD, outD, act) {
                this.act = act;
                let s = Math.sqrt(2 / (inD + outD)); // Xavier Init
                this.w = Array.from({ length: inD }, () => Array.from({ length: outD }, () => (Math.random() * 2 - 1) * s));
                this.b = new Array(outD).fill(0);
                this.lastZ = []; this.lastA = [];
            }
            forward(X) {
                // Linear Step: Z = XW + B
                this.lastZ = X.map(row => this.b.map((b, j) => row.reduce((sum, v, i) => sum + v * this.w[i][j], 0) + b));

                // Activation Step
                if (this.act === 'softmax') {
                    this.lastA = this.lastZ.map(row => Act.softmax.f(row));
                } else {
                    this.lastA = this.lastZ.map(row => row.map(v => Act[this.act].f(v)));
                }
                return this.lastA;
            }
        }


        let currentMode = 'LOGIC'; // Default

        function updateTestUI(type) {
            const container = document.getElementById('dynamicTestUI');
            container.innerHTML = ''; // Clear previous
            currentMode = type;

            if (['XOR', 'XNOR', 'XOR3', 'XNOR3'].includes(type)) {
                const inputs = type.includes('3') ? 3 : 2;
                let html = '<div style="display:flex; gap:15px; align-items:center;">';
                for (let i = 0; i < inputs; i++) {
                    html += `<label style="color:#888">BIT ${i} <input type="checkbox" class="logic-sw" onchange="runLiveTest()" style="width:20px; height:20px;"></label>`;
                }
                html += '<div id="bulb" style="width:30px; height:30px; border-radius:50%; background:#333; border:2px solid #555; margin-left:20px; transition: 0.2s;"></div>';
                html += '<span id="logicVal" style="margin-left:10px; font-weight:bold;">0.00</span></div>';
                container.innerHTML = html;
            }
            else if (['SIN', 'COS'].includes(type)) {
                container.innerHTML = `
    <div style="display:flex; flex-direction:column; gap:5px;">
        <label>Range Evaluation:</label>
        <div style="display:flex; gap:5px;">
            <input type="number" id="rangeStart" value="0" step="0.1" style="flex:1" oninput="runLiveTest()">
            <input type="number" id="rangeEnd" value="6.28" step="0.1" style="flex:1" oninput="runLiveTest()">
            <input type="number" id="rangeSteps" value="50" style="flex:0.5" oninput="runLiveTest()">
        </div>
        <div id="mathResultDisplay" style="color:var(--neon); font-size:0.8rem; margin-top:5px;">
            Generating curve...
        </div>
    </div>`;
            }
            else if (type === 'MOON') {
                container.innerHTML = `
        <div style="display:flex; flex-direction:column; gap:10px;">
            <div style="display:flex; gap:5px">
                <input type="number" id="moonX" value="0.5" step="0.1" oninput="runLiveTest()" placeholder="X">
                <input type="number" id="moonY" value="0.2" step="0.1" oninput="runLiveTest()" placeholder="Y">
            </div>
            <div style="display:flex; justify-content:around; align-items:center; background:#000; padding:10px; border-radius:5px;">
                <div style="text-align:center">
                    <div id="orbA" style="width:30px; height:30px; border-radius:50%; background:#333; border:2px solid #ff3131; margin:auto;"></div>
                    <label style="font-size:10px">MOON A</label>
                </div>
                <div style="text-align:center; margin-left:20px;">
                    <div id="orbB" style="width:30px; height:30px; border-radius:50%; background:#333; border:2px solid #00ff41; margin:auto;"></div>
                    <label style="font-size:10px">MOON B</label>
                </div>
            </div>
        </div>`;
            }
            else if (type === 'COLOR') {
                container.innerHTML = `
            <label>Pick Color:</label>
            <input type="color" id="colPick" oninput="runLiveTest()" style="height:40px;">`;
            }
        }
        function updateMathLabel(val) {
            const unit = document.getElementById('mathUnit').value;
            const displayVal = unit === 'deg' ? (val * 180 / Math.PI).toFixed(1) + "°" : val + " rad";
            document.getElementById('mathValDisplay').innerText = displayVal;
            runLiveTest();
        }
        // Helper to run prediction automatically on UI change
        function runLiveTest() {

            if (['SIN', 'COS'].includes(currentMode)) {
                const start = parseFloat(document.getElementById('rangeStart').value);
                const end = parseFloat(document.getElementById('rangeEnd').value);
                const steps = parseInt(document.getElementById('rangeSteps').value);

                let rangeInputs = [];
                let xValues = [];

                for (let i = 0; i <= steps; i++) {
                    let val = start + (i * (end - start) / steps);
                    xValues.push(val);
                    rangeInputs.push([val]); // Network expects array of arrays [[x1], [x2]...]
                }

                if (layers.length > 0) executeRangeInference(xValues, rangeInputs);
                return
            }

            let inputVector = [];

            if (['XOR', 'XNOR', 'XOR3', 'XNOR3'].includes(currentMode)) {
                inputVector = Array.from(document.querySelectorAll('.logic-sw')).map(sw => sw.checked ? 1 : 0);
            } else if (['SIN', 'COS'].includes(currentMode)) {
                inputVector = [parseFloat(document.querySelector('#dynamicTestUI input[type="range"]').value)];
            } else if (currentMode === 'MOON') {
                inputVector = [parseFloat(document.getElementById('moonX').value), parseFloat(document.getElementById('moonY').value)];
            } else if (currentMode === 'COLOR') {
                const hex = document.getElementById('colPick').value;
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                inputVector = [r, g, b];
            }

            if (layers.length > 0) executeInference(inputVector);
        }

        function executeRangeInference(xValues, rangeInputs) {
            let currentA = rangeInputs;
            for (let L of layers) currentA = L.forward(currentA);

            // Rescale outputs back to -1 to 1 range for visualization
            const yValues = currentA.map(out => (out[0] * 2) - 1);

            const trace = {
                x: xValues,
                y: yValues,
                mode: 'lines',
                name: 'Model Range Prediction',
                line: { color: '#00ff41', width: 3 }
            };

            const layout = {
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: { color: '#0f0' },
                margin: { t: 10, b: 30, l: 30, r: 10 },
                xaxis: { title: 'Input (rad)' },
                yaxis: { title: 'f(x)' }
            };

            Plotly.react('plot', [trace], layout);
            document.getElementById('mathResultDisplay').innerText = `Plotted ${xValues.length} points across range.`;
        }

        function executeInference(inputVector) {
            if (['SIN', 'COS'].includes(currentMode)) {
                inputVector = [inputVector[0] % (Math.PI * 2)];
            }
            let currentA = [inputVector];
            for (let L of layers) currentA = L.forward(currentA);
            const outputs = currentA[0];

            const resultDiv = document.getElementById('predictionResult');

            if (['XOR', 'XNOR', 'XOR3', 'XNOR3'].includes(currentMode)) {
                const val = outputs[0];
                document.getElementById('bulb').style.background = `rgba(0, 255, 65, ${val})`;
                document.getElementById('bulb').style.boxShadow = val > 0.5 ? `0 0 15px #00ff41` : 'none';
                document.getElementById('logicVal').innerText = val.toFixed(3);
                resultDiv.innerHTML = `Signal: ${(val * 100).toFixed(1)}%`;
            }
            else if (currentMode === 'MOON') {
                const val = outputs[0]; // Assuming 1 output neuron for binary
                const probB = val;
                const probA = 1 - val;

                // Update Orb A (Red - Class 0)
                document.getElementById('orbA').style.background = `rgba(255, 49, 49, ${probA})`;
                document.getElementById('orbA').style.boxShadow = probA > 0.5 ? `0 0 15px #ff3131` : 'none';

                // Update Orb B (Green - Class 1)
                document.getElementById('orbB').style.background = `rgba(0, 255, 65, ${probB})`;
                document.getElementById('orbB').style.boxShadow = probB > 0.5 ? `0 0 15px #00ff41` : 'none';

                resultDiv.innerHTML = `Classification: ${val > 0.5 ? 'Moon B' : 'Moon A'} (${(val * 100).toFixed(1)}%)`;
            }
            else if (['SIN', 'COS'].includes(currentMode)) {
                const rawVal = outputs[0];
                const finalVal = (rawVal * 2) - 1;
                document.getElementById('mathResultDisplay').innerText = `f(x) ≈ ${finalVal.toFixed(4)}`;
                resultDiv.innerHTML = `Regression Output: ${rawVal.toFixed(4)}`;
            }
            else {
                displayOutputResults(outputs); // Handles Color
            }
        }

        function displayOutputResults(outputs) {
            let html = `<div style="color: #fff; margin-top:10px;">Network Output:</div>`;
            outputs.forEach((val, i) => {
                html += `
        <div style="margin-bottom: 4px;">
            <span style="font-size:0.7rem">${i === 0 ? 'WARM' : i === 1 ? 'NEUTRAL' : 'COOL'}: ${(val * 100).toFixed(1)}%</span>
            <div style="background: #333; width: 100%; height: 8px;">
                <div style="background: var(--neon); width: ${val * 100}%; height: 100%;"></div>
            </div>
        </div>`;
            });
            document.getElementById('predictionResult').innerHTML = html;
        }

        // --- DATASET GENERATORS ---
        function setDataset(type, btnElement) {
            // 1. UI Highlight Logic
            document.querySelectorAll('.btn-group button').forEach(btn => btn.classList.remove('active-dataset'));
            if (btnElement) btnElement.classList.add('active-dataset');

            // 2. Clear previous inference/results
            document.getElementById('predictionResult').innerHTML = "Result: awaiting input...";
            lossHistory = []; // Reset loss history for the new dataset

            // 3. Dataset Definitions
            if (type === 'XOR') {
                document.getElementById('inputX').value = "0,0; 0,1; 1,0; 1,1";
                document.getElementById('inputY').value = "0; 1; 1; 0";
            } else if (type === 'XNOR') {
                document.getElementById('inputX').value = "0,0; 0,1; 1,0; 1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1";
            } else if (type === 'XOR3') {
                document.getElementById('inputX').value = "0,0,0; 0,0,1; 0,1,0; 0,1,1; 1,0,0; 1,0,1; 1,1,0; 1,1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1; 0; 1; 1; 0";
            } else if (type === 'XNOR3') {
                document.getElementById('inputX').value = "0,0,0; 0,0,1; 0,1,0; 0,1,1; 1,0,0; 1,0,1; 1,1,0; 1,1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1; 0; 1; 1; 0";
            } else if (type === 'COS') {
                let x = [], y = [];
                for (let i = 0; i <= 20; i++) { x.push(i / 5); y.push((Math.cos(i / 5 * Math.PI) + 1) / 2); }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            } else if (type === 'SIN') {
                let x = [], y = [];
                for (let i = 0; i <= 20; i++) { x.push(i / 5); y.push((Math.sin(i / 5 * Math.PI) + 1) / 2); }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            } else if (type === 'MOON') {
                let x = [], y = [];
                for (let i = 0; i < 40; i++) {
                    let p = (i / 40) * Math.PI;
                    x.push(`${Math.cos(p).toFixed(2)},${Math.sin(p).toFixed(2)}`); y.push(0);
                    x.push(`${(1 - Math.cos(p)).toFixed(2)},${(0.5 - Math.sin(p)).toFixed(2)}`); y.push(1);
                }
                document.getElementById('inputX').value = x.join('; ');
                document.getElementById('inputY').value = y.join('; ');
            }

            updateTestUI(type);
            buildNetwork();
        }

        function addLayerUI() {
            const div = document.createElement('div');
            div.style = "display:flex; gap:2px; margin-top:2px;";
            div.innerHTML = `<input type="number" class="l-size" value="4"> <select class="l-act"><option value="tanh">Tanh</option><option value="relu">ReLU</option><option value="lrelu">Leaky ReLU</option></select> <button onclick="this.parentElement.remove()" style="width:30px">x</button>`;
            document.getElementById('layersConfig').appendChild(div);
        }

        function buildNetwork() {
            const xRaw = document.getElementById('inputX').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
            const yRaw = document.getElementById('inputY').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));

            layers = [];
            let curIn = xRaw[0].length;

            // Build Hidden Layers
            document.querySelectorAll('#layersConfig > div:not([style*="border-top"])').forEach(el => {
                let sInput = el.querySelector('.l-size');
                if (!sInput) return; // Skip the output config div
                let s = parseInt(sInput.value);
                let a = el.querySelector('.l-act').value;
                layers.push(new Layer(curIn, s, a));
                curIn = s;
            });

            // NEW: Build Output Layer based on User Choice
            const outputDim = yRaw[0].length;
            const finalAct = document.getElementById('outputAct').value;
            layers.push(new Layer(curIn, outputDim, finalAct));

            renderWeights();
            drawNet();
            document.getElementById('status').innerText = "Status: Network Built. Ready to Train.";
        }


        function predictUniversal() {
            if (layers.length === 0) {
                document.getElementById('predictionResult').innerText = "Error: Build and train the network first.";
                return;
            }

            // 1. Parse the input string
            const inputStr = document.getElementById('testInput').value;
            const inputVector = inputStr.split(',').map(v => parseFloat(v.trim()));

            // Validation: Ensure input length matches the first layer's weights
            if (inputVector.length !== layers[0].w.length) {
                document.getElementById('predictionResult').innerText =
                    `Error: Expected ${layers[0].w.length} inputs, but got ${inputVector.length}.`;
                return;
            }

            // 2. Forward Pass: Pass the input through all layers
            let currentA = [inputVector];
            for (let L of layers) {
                currentA = L.forward(currentA);
            }

            // 3. Display Results
            const outputs = currentA[0];
            let html = `<div style="color: #fff; margin-bottom: 5px;">Output Activations:</div>`;

            outputs.forEach((val, i) => {
                const percentage = (val * 100).toFixed(2);
                // Create a simple visual bar for each output
                html += `
            <div style="margin-bottom: 4px;">
                <span style="display:inline-block; width: 80px;">Out[${i}]:</span>
                <span style="color: #00ff41;">${percentage}%</span>
                <div style="background: #333; width: 100%; height: 4px; margin-top: 2px;">
                    <div style="background: #00ff41; width: ${val * 100}%; height: 100%;"></div>
                </div>
            </div>`;
            });

            // For classification: Highlight the winner
            const maxIdx = outputs.indexOf(Math.max(...outputs));
            html += `<div style="margin-top: 8px; border-top: 1px solid #444; padding-top: 5px;">
                Primary Class: <strong style="color:#00ff41;">Index ${maxIdx}</strong>
             </div>`;

            document.getElementById('predictionResult').innerHTML = html;
        }

        function setColorDataset(btnElement) {
            if (btnElement) btnElement.classList.add('active-dataset');
            const data = [
                // --- WARM COLORS (Output: 1,0,0) ---
                { x: "1,0,0", y: "1,0,0" }, { x: "1,0.1,0.1", y: "1,0,0" }, { x: "0.8,0.2,0", y: "1,0,0" },
                { x: "1,0.5,0", y: "1,0,0" }, { x: "0.9,0.4,0.1", y: "1,0,0" }, { x: "1,0.8,0", y: "1,0,0" },
                { x: "0.7,0,0", y: "1,0,0" }, { x: "0.6,0.2,0.1", y: "1,0,0" }, { x: "1,0.3,0.3", y: "1,0,0" },
                { x: "0.9,0.6,0.2", y: "1,0,0" }, { x: "0.8,0.1,0.2", y: "1,0,0" }, { x: "1,0.2,0", y: "1,0,0" },
                { x: "0.5,0.1,0", y: "1,0,0" }, { x: "1,0.4,0.4", y: "1,0,0" }, { x: "0.8,0.5,0", y: "1,0,0" },

                // --- COOL COLORS (Output: 0,1,0) ---
                { x: "0,0,1", y: "0,1,0" }, { x: "0.1,0.1,0.9", y: "0,1,0" }, { x: "0,0.5,1", y: "0,1,0" },
                { x: "0,1,1", y: "0,1,0" }, { x: "0.2,0.8,0.8", y: "0,1,0" }, { x: "0,0.3,0.7", y: "0,1,0" },
                { x: "0.1,0.4,0.9", y: "0,1,0" }, { x: "0,0,0.6", y: "0,1,0" }, { x: "0.3,0.5,0.8", y: "0,1,0" },
                { x: "0,0.7,0.7", y: "0,1,0" }, { x: "0.1,0.2,0.6", y: "0,1,0" }, { x: "0.4,0.7,1", y: "0,1,0" },
                { x: "0,0.5,0.5", y: "0,1,0" }, { x: "0.2,0.3,0.9", y: "0,1,0" }, { x: "0.1,0.6,0.6", y: "0,1,0" },

                // --- NEUTRAL/MUTED (Output: 0,0,1) ---
                { x: "0.5,0.5,0.5", y: "0,0,1" }, { x: "0.2,0.2,0.2", y: "0,0,1" }, { x: "0.8,0.8,0.8", y: "0,0,1" },
                { x: "1,1,1", y: "0,0,1" }, { x: "0,0,0", y: "0,0,1" }, { x: "0.4,0.4,0.4", y: "0,0,1" },
                { x: "0.6,0.6,0.6", y: "0,0,1" }, { x: "0.3,0.3,0.3", y: "0,0,1" }, { x: "0.9,0.9,0.9", y: "0,0,1" },
                { x: "0.5,0.5,0.6", y: "0,0,1" }, { x: "0.4,0.5,0.4", y: "0,0,1" }, { x: "0.5,0.4,0.4", y: "0,0,1" },
                { x: "0.1,0.1,0.1", y: "0,0,1" }, { x: "0.7,0.7,0.7", y: "0,0,1" }, { x: "0.2,0.2,0.25", y: "0,0,1" },

                // --- CHALLENGING GRADIENTS ---
                { x: "0.5,0.2,0.2", y: "1,0,0" }, // Muddy Red (Warm)
                { x: "0.2,0.2,0.5", y: "0,1,0" }, // Muddy Blue (Cool)
                { x: "0.6,0.6,0.5", y: "0,0,1" }, // Off-Grey (Neutral)
                { x: "0.5,0.4,0.3", y: "1,0,0" }, // Brownish (Warm)
                { x: "0.3,0.4,0.5", y: "0,1,0" }  // Slate (Cool)
            ];

            document.getElementById('inputX').value = data.map(d => d.x).join('; ');
            document.getElementById('inputY').value = data.map(d => d.y).join('; ');

            updateTestUI('COLOR');
            buildNetwork();

        }

        async function toggleTraining() {
            if (isTraining) return;
            if (layers.length === 0) buildNetwork();

            isTraining = true; stopFlag = false;
            document.getElementById('trainBtn').innerText = "TRAINING...";

            const xRaw = document.getElementById('inputX').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
            const yRaw = document.getElementById('inputY').value.split(';').map(r => r.split(',').filter(v => v.trim() !== "").map(v => parseFloat(v.trim())));

            const maxEpochs = parseInt(document.getElementById('epochs').value);
            const delay = parseInt(document.getElementById('delay').value);
            const lr = parseFloat(document.getElementById('lr').value);

            lossHistory = [];
            for (let ep = 0; ep <= maxEpochs; ep++) {
                while (isPaused) await new Promise(r => setTimeout(r, 100));
                if (stopFlag) break;

                // Forward
                let acts = [xRaw];
                for (let L of layers) acts.push(L.forward(acts[acts.length - 1]));

                // Backward
                let out = acts[acts.length - 1];
                let error = out.map((row, i) => row.map((v, j) => v - yRaw[i][j]));
                let mse = error.flat().reduce((a, b) => a + b * b, 0) / xRaw.length;
                lossHistory.push(mse);

                let dZ = error.map((row, i) => row.map((err, j) => err * (2 / xRaw.length) * Act[layers[layers.length - 1].act].df(layers[layers.length - 1].lastZ[i][j])));

                for (let i = layers.length - 1; i >= 0; i--) {
                    let L = layers[i], prevA = acts[i];
                    let dW = L.w.map((row, rI) => row.map((_, cI) => dZ.reduce((s, dzR, rI2) => s + dzR[cI] * prevA[rI2][rI], 0)));
                    let dB = dZ[0].map((_, cI) => dZ.reduce((s, dzR) => s + dzR[cI], 0));

                    if (i > 0) {
                        let prevL = layers[i - 1];
                        dZ = dZ.map((dzR, rI) => prevL.w[0].map((_, cI) => {
                            let da = dzR.reduce((s, dzV, curCI) => s + dzV * L.w[cI][curCI], 0);
                            return da * Act[prevL.act].df(prevL.lastZ[rI][cI]);
                        }));
                    }
                    L.w = L.w.map((row, r) => row.map((v, c) => v - lr * dW[r][c]));
                    L.b = L.b.map((v, c) => v - lr * dB[c]);
                }

                if (ep % 20 === 0) {
                    updateViz(xRaw, yRaw, out, mse, ep);
                    renderWeights();
                    await new Promise(r => setTimeout(r, delay));
                }
            }
            isTraining = false;
            document.getElementById('trainBtn').innerText = "START TRAINING";
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').innerText = isPaused ? "RESUME" : "PAUSE";
        }
        function updateViz(x, y, preds, loss, ep) {
            document.getElementById('status').innerText = `Epoch: ${ep} | Loss: ${loss.toFixed(4)}`;
            const inDim = x[0].length;
            const outDim = y[0].length;
            let traces = [];

            // --- CASE 1: 1D REGRESSION (SIN/COS) ---
            if (inDim === 1) {
                traces.push({
                    x: x.map(r => r[0]),
                    y: y.map(r => r[0]),
                    mode: 'markers',
                    name: 'Target',
                });
                traces.push({
                    x: x.map(r => r[0]),
                    y: preds.map(r => r[0]),
                    mode: 'lines',
                    name: 'Network',
                });
            }
            // --- CASE 2: 2D or 3D CLASSIFICATION (XOR, MOONS, COLOR) ---
            else {
                // Draw Decision Boundary for 2-Input models
                if (inDim === 2) {
                    const resolution = 25;
                    let gridX = [], gridY = [], gridZ = [];
                    for (let i = 0; i <= resolution; i++) {
                        let px = -0.5 + (i / resolution) * 2;
                        gridX.push(px);
                        let rowZ = [];
                        for (let j = 0; j <= resolution; j++) {
                            let py = -0.5 + (j / resolution) * 2;
                            if (i === 0) gridY.push(py);

                            let out = [px, py];
                            for (let L of layers) out = L.forward([out])[0];

                            // Color Logic: If Color Dataset (3 outputs), mix colors
                            if (outDim === 3) {
                                rowZ.push(out[0] - out[1]); // Simplified contrast for heatmap
                            } else {
                                rowZ.push(out[0]);
                            }
                        }
                        gridZ.push(rowZ);
                    }
                    traces.push({
                        x: gridX, y: gridY, z: gridZ,
                        type: 'heatmap',
                        colorscale: [[0, '#440000'], [0.5, '#1a1a1a'], [1, '#00441b']],
                        showscale: false, opacity: 0.4, transpose: true
                    });
                }

                // Plot Data Points
                traces.push({
                    x: x.map(r => r[0]),
                    y: x.map(r => r[1]),
                    mode: 'markers',
                    name: 'Data',
                    marker: {
                        // If color data, use the RGB values directly. Otherwise, Green/Red.
                        color: outDim === 3 ? x.map(r => `rgb(${r[0] * 255},${r[1] * 255},${r[2] * 255})`) : y.map(r => r[0] > 0.5 ? '#00ff41' : '#ff3131'),
                        size: 10,
                        line: { color: '#fff', width: 1 }
                    }
                });
            }

            const layout = {
                paper_bgcolor: '#1a1a1a', plot_bgcolor: '#1a1a1a',
                font: { color: '#0f0' }, margin: { t: 10, b: 30, l: 30, r: 10 },
                xaxis: { gridcolor: '#222' }, yaxis: { gridcolor: '#222' }
            };

            Plotly.react('plot', traces, layout);
            Plotly.react('lossPlot', [{ y: lossHistory, type: 'scatter', line: { color: 'red' } }],
                { ...layout, yaxis: { type: 'log', title: 'Loss' } });
            drawNet();
        }
        function renderWeights() {
            let html = "";
            layers.forEach((L, i) => {
                // Create a container for each layer's weights
                html += `<div class="matrix-table">
                    <div class="layer-title">Layer ${i} → ${i + 1} (${L.act})</div>
                    <table>`;

                // Rows = Input Neurons, Cols = Output Neurons
                L.w.forEach((row, rIdx) => {
                    html += "<tr>";
                    row.forEach(v => {
                        // Color coding: Green for positive, Red for negative
                        const color = isNaN(v) ? '#ffff00' : v > 0 ? '#00ff41' : '#ff3131';
                        const opacity = Math.min(1, Math.abs(v));
                        html += `<td style="color:${color}; opacity:${0.3 + opacity}">${v.toFixed(4)}</td>`;
                    });
                    html += "</tr>";
                });

                html += `</table><div class="layer-title">Biases</div><table><tr>`;
                L.b.forEach(v => {
                    html += `<td>${v.toFixed(4)}</td>`;
                });
                html += "</tr></table></div>";
            });
            document.getElementById('matrixDisplay').innerHTML = html;
        }

        function drawNet() {
            const canvas = document.getElementById('netCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            if (layers.length === 0) return;
            const counts = [layers[0].w.length, ...layers.map(l => l.w[0].length)];
            const xStep = canvas.width / (counts.length + 1);
            const pos = counts.map((c, i) => Array.from({ length: c }, (_, j) => ({ x: xStep * (i + 1), y: (canvas.height / (c + 1)) * (j + 1) })));

            layers.forEach((L, lIdx) => {
                L.w.forEach((row, i) => row.forEach((w, j) => {
                    ctx.beginPath(); ctx.moveTo(pos[lIdx][i].x, pos[lIdx][i].y); ctx.lineTo(pos[lIdx + 1][j].x, pos[lIdx + 1][j].y);
                    ctx.strokeStyle = isNaN(w) ? '#ffff00' : w > 0 ? `rgba(0,255,65,${Math.abs(w)})` : `rgba(255,0,0,${Math.abs(w)})`;
                    ctx.lineWidth = Math.min(5, Math.abs(w) * 2); ctx.stroke();
                }));
            });
            pos.flat().forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, 7); ctx.fillStyle = "#00ff41"; ctx.fill(); });
        }
    </script>
</body>

</html>