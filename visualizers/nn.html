<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Neural Network Demystified</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        .active-dataset {
            background: #00441b !important;
            border-color: #fff !important;
            box-shadow: 0 0 10px var(--neon);
            color: #fff !important;
        }

        :root {
            --neon: #cbd5e1;
            --bg: #020617;
            --panel: #0f172a;
        }

        body {
            font-family: 'Consolas', monospace;
            background: var(--bg);
            color: var(--neon);
            padding: 20px;
            margin: 0;
        }

        /* Add this to your CSS */
        .controls>div {
            border-bottom: 1px solid #2d3748;
            padding-bottom: 15px;
            margin-bottom: 5px;
        }

        .controls input,
        .controls select {
            height: 32px;
            /* Forces consistent height across all input types */
            box-sizing: border-box;
        }

        .dashboard {
            display: grid;
            /* Move controls to a narrow left column, plots to a wide right column */
            grid-template-columns: 320px 1fr 1fr;
            grid-template-rows: auto auto;
            gap: 20px;
            width: 98vw;
            max-width: 1800px;
            margin: auto;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #334155;
            padding: 15px;
            border-radius: 8px;
        }

        /* Make the Network Topology span across both plot columns */
        .panel[style*="grid-column: span 2"] {
            grid-column: 2 / span 2 !important;
        }

        .controls {
            /* Set controls to stay in the first column and span downward */
            grid-column: 1;
            grid-row: 1 / span 3;
            display: flex;
            flex-direction: column;
            gap: 12px;
            background: #0f172a;
            padding: 15px;
            border: 1px solid #334155;
            height: fit-content;
            overflow-y: auto;
        }

        canvas {
            background: #00070a;
            width: 100%;
            height: 400px;
            /* Increased from 250px to 400px for better vertical spread */
            border: 1px solid #222;
            margin-top: 10px;
        }

        input,
        select,
        button {
            background: #000;
            color: var(--neon);
            border: 1px solid var(--neon);
            padding: 8px;
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #003311;
        }

        /* Weight Grid Styling */
        #weightInspector {
            grid-column: 2 / span 2;
            /* Align it under the plots */
            max-height: 200px;
            /* Set a strict height */
            overflow-x: auto;
            /* Allow horizontal scrolling for many layers */
            white-space: nowrap;
            /* Keep layers side-by-side */
            border-top: 2px solid #334155;
            padding-top: 10px;
        }

        .matrix-table {
            border-collapse: collapse;
            margin: 5px;
            display: inline-block;
            vertical-align: top;
            border: 1px solid #334155;
            background: #020617;
            /* Darker contrast for the table itself */
            font-size: 0.65rem;
            /* Smaller font for high-density data */
        }

        .matrix-table td {
            border: 1px solid #1e293b;
            padding: 2px 6px;
            min-width: 45px;
        }

        .layer-title {
            color: #fff;
            text-transform: uppercase;
            font-size: 0.8rem;
            border-bottom: 1px solid var(--neon);
            margin-bottom: 5px;
        }

        .btn-group {
            display: flex;
            flex-wrap: wrap;
            /* Allows buttons to drop to a new line */
            gap: 4px;
            /* Tighter gap to save space */
            margin-top: 5px;
        }

        .btn-group button {
            flex: 1 1 calc(33% - 4px);
            /* Fits roughly 3 buttons per row */
            min-width: 60px;
            /* Prevents buttons from getting too tiny */
            font-size: 0.7rem;
            /* Slightly smaller text for better fit */
            padding: 6px 2px;
            /* Vertical padding, minimal horizontal */
            white-space: nowrap;
            /* Prevents text from breaking mid-word */
            overflow: hidden;
            text-overflow: ellipsis;
            /* Adds '...' if text is still too long */
        }

        label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }
    </style>
</head>

<body>

    <h2 style="text-align: center;">NEURAL ARCHITECT & TRACE ENGINE</h2>

    <div class="dashboard">
        <div class="controls">
            <div>
                <label>Data Management</label>
                <input id="inputX" value="0,0; 0,1; 1,0; 1,1">
                <input id="inputY" value="1; 0; 0; 1">
                <div class="btn-group" style="margin-bottom: 15px;">
                    <button onclick="setDataset('XOR', this)">XOR</button>
                    <button onclick="setDataset('XNOR', this)">XNOR</button>
                    <button onclick="setDataset('XOR3', this)">3 Input XOR</button>
                    <button onclick="setDataset('XNOR3', this)">3 Input XNOR</button>
                    <button onclick="setDataset('SIN', this)">SIN</button>
                    <button onclick="setDataset('COS', this)">COS</button>
                    <button onclick="setDataset('MOON', this)">MOONS</button>
                    <button onclick="setColorDataset(this)">Color Data Set</button>
                </div>

                <br />

                <div>
                    <label>Model Inference & Live Test</label>
                    <div id="dynamicTestUI"
                        style="background: #111; padding: 10px; border: 1px solid #333; margin-top: 5px; min-height: 80px;">
                    </div>
                    <div id="predictionResult" style="margin-top: 10px; font-size: 0.85rem;">
                        Result: awaiting input...
                    </div>
                </div>
            </div>

            <div>
                <label>Network Structure</label>
                <div id="layersConfig">
                    <div style="display:flex; gap:2px">
                        <input type="number" class="l-size" value="4">
                        <select class="l-act">
                            <option value="tanh">Tanh</option>
                            <option value="relu">ReLU</option>
                            <option value="lrelu">Leaky ReLU</option>
                        </select>
                    </div>
                </div>
                <button onclick="addLayerUI()">+ ADD LAYER</button>
                <button onclick="buildNetwork()" style="background: #222;">BUILD NETWORK</button>
                <div style="margin-top: 10px; border-top: 1px solid #444; pt: 5px;">
                    <label>Output Layer Activation</label>
                    <select id="outputAct">
                        <option value="sigmoid">Sigmoid (Classification 0-1)</option>
                        <option value="softmax">Softmax (Multi-class)</option>
                        <option value="linear">Regression (Linear)</option>
                    </select>
                </div>
            </div>

            <div>
                <label>Training Parameters</label>
                <div style="display:flex; gap:5px">
                    <div style="flex:1"><label>Epochs</label><input type="number" id="epochs" value="2000"></div>
                    <div style="flex:1"><label>Delay(ms)</label><input type="number" id="delay" value="10"></div>
                </div>
                <label>Learning Rate</label>
                <input type="number" id="lr" value="0.1" step="0.01">
            </div>

            <div>
                <label>Execution</label>
                <select id="plotMode">
                    <option value="auto">Auto (Adaptive)</option>
                    <option value="pca">Force PCA</option>
                    <option value="2d">Force 2D</option>
                </select>
                <button id="trainBtn" onclick="toggleTraining()"
                    style="background:#334155; font-size: 1.1rem; height: 60px;">START TRAINING</button>
                <div class="btn-group">
                    <button onclick="stopFlag=true" style="background:#440000">STOP</button>
                    <button id="pauseBtn" onclick="togglePause()">PAUSE</button>
                </div>
                <div id="status" style="margin-top:10px;">Status: Awaiting Initialization</div>
            </div>
        </div>
        <div class="panel"><label>Prediction Plot</label>
            <div id="plot" style="height: 400px;"></div>
        </div>
        <div class="panel"><label>Loss History</label>
            <div id="lossPlot" style="height: 400px;"></div>
        </div>


        <div class="panel" style="grid-column: span 2;">
            <label>Topology & Weight Magnitude (Live)</label>
            <canvas id="netCanvas"></canvas>

        </div>

        <div id="weightInspector" class="panel">
            <label>Numerical Weight & Bias Matrices (Trace)</label>
            <div id="matrixDisplay"></div>
        </div>



    </div>

    <script>
        let layers = [], isTraining = false, isPaused = false, stopFlag = false, lossHistory = [];

        const Act = {
            relu: { f: x => Math.max(0, x), df: x => x > 0 ? 1 : 0 },
            tanh: { f: x => Math.tanh(x), df: x => 1 - Math.pow(Math.tanh(x), 2) },
            sigmoid: { f: x => 1 / (1 + Math.exp(-x)), df: x => { let s = 1 / (1 + Math.exp(-x)); return s * (1 - s); } },
            lrelu: { f: x => x > 0 ? x : 0.01 * x, df: x => x > 0 ? 1 : 0.01 },
            softmax: {
                // Softmax is applied to a whole row (array)
                f: (arr) => {
                    const max = Math.max(...arr); // For numerical stability
                    const exps = arr.map(v => Math.exp(v - max));
                    const sum = exps.reduce((a, b) => a + b);
                    return exps.map(v => v / sum);
                },
                df: x => 1
            },
            linear: { f: x => x, df: x => 1 }
        };

        class Layer {
            constructor(inD, outD, act) {
                this.act = act;
                let s = Math.sqrt(2 / (inD + outD)); // Xavier Init
                this.w = Array.from({ length: inD }, () => Array.from({ length: outD }, () => (Math.random() * 2 - 1) * s));
                this.b = new Array(outD).fill(0);
                this.lastZ = []; this.lastA = [];
            }
            forward(X) {
                // Linear Step: Z = XW + B
                this.lastZ = X.map(row => this.b.map((b, j) => row.reduce((sum, v, i) => sum + v * this.w[i][j], 0) + b));

                // Activation Step
                if (this.act === 'softmax') {
                    this.lastA = this.lastZ.map(row => Act.softmax.f(row));
                } else {
                    this.lastA = this.lastZ.map(row => row.map(v => Act[this.act].f(v)));
                }
                return this.lastA;
            }
        }


        let currentMode = 'LOGIC'; // Default

        function updateTestUI(type) {
            const container = document.getElementById('dynamicTestUI');
            container.innerHTML = ''; // Clear previous
            currentMode = type;

            if (['XOR', 'XNOR', 'XOR3', 'XNOR3'].includes(type)) {
                const inputs = type.includes('3') ? 3 : 2;
                let html = '<div style="display:flex; gap:15px; align-items:center;">';
                for (let i = 0; i < inputs; i++) {
                    html += `<label style="color:#888">BIT ${i} <input type="checkbox" class="logic-sw" onchange="runLiveTest()" style="width:20px; height:20px;"></label>`;
                }
                html += '<div id="bulb" style="width:30px; height:30px; border-radius:50%; background:#333; border:2px solid #555; margin-left:20px; transition: 0.2s;"></div>';
                html += '<span id="logicVal" style="margin-left:10px; font-weight:bold;">0.00</span></div>';
                container.innerHTML = html;
            }
            else if (['SIN', 'COS'].includes(type)) {
                container.innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:5px;">
                        <label>Range Evaluation:</label>
                        <div style="display:flex; gap:5px;">
                            <input type="number" id="rangeStart" value="0" step="0.1" style="flex:1" oninput="runLiveTest()">
                            <input type="number" id="rangeEnd" value="6.28" step="0.1" style="flex:1" oninput="runLiveTest()">
                            <input type="number" id="rangeSteps" value="50" style="flex:0.5" oninput="runLiveTest()">
                        </div>
                        <div id="mathResultDisplay" style="color:var(--neon); font-size:0.8rem; margin-top:5px;">
                            Generating curve...
                        </div>
                    </div>`;
            }
            else if (type === 'MOON') {
                container.innerHTML = `
                    <div style="display:flex; flex-direction:column; gap:10px;">
                        <div style="display:flex; gap:5px">
                            <div style="flex:1">
                                <label style="display:block; font-size:9px;">INPUT 0 (X-AXIS)</label>
                                <input type="number" id="moonX" value="0.5" step="0.1" oninput="runLiveTest()" placeholder="X">
                            </div>
                            <div style="flex:1">
                                <label style="display:block; font-size:9px;">INPUT 1 (Y-AXIS)</label>
                                <input type="number" id="moonY" value="0.2" step="0.1" oninput="runLiveTest()" placeholder="Y">
                            </div>
                        </div>
                        <div style="display:flex; justify-content:space-around; align-items:center; background:#000; padding:10px; border-radius:5px; border: 1px solid #333;">
                            <div style="text-align:center">
                                <div id="orbA" style="width:30px; height:30px; border-radius:50%; background:#333; border:2px solid #ff3131; margin:auto;"></div>
                                <label style="font-size:10px">CLASS A (RED)</label>
                            </div>
                            <div style="text-align:center">
                                <div id="orbB" style="width:30px; height:30px; border-radius:50%; background:#333; border:2px solid #00ff41; margin:auto;"></div>
                                <label style="font-size:10px">CLASS B (GREEN)</label>
                            </div>
                        </div>
                    </div>`;
            }
            else if (type === 'COLOR') {
                container.innerHTML = `
            <label>Pick Color:</label>
            <input type="color" id="colPick" oninput="runLiveTest()" style="height:40px;">`;
            }
        }
        function updateMathLabel(val) {
            const unit = document.getElementById('mathUnit').value;
            const displayVal = unit === 'deg' ? (val * 180 / Math.PI).toFixed(1) + "°" : val + " rad";
            document.getElementById('mathValDisplay').innerText = displayVal;
            runLiveTest();
        }
        // Helper to run prediction automatically on UI change
        function runLiveTest() {

            if (['SIN', 'COS'].includes(currentMode)) {
                const start = parseFloat(document.getElementById('rangeStart').value);
                const end = parseFloat(document.getElementById('rangeEnd').value);
                const steps = parseInt(document.getElementById('rangeSteps').value);

                let rangeInputs = [];
                let xValues = [];

                for (let i = 0; i <= steps; i++) {
                    let val = start + (i * (end - start) / steps);
                    xValues.push(val);
                    rangeInputs.push([val]); // Network expects array of arrays [[x1], [x2]...]
                }

                if (layers.length > 0) executeRangeInference(xValues, rangeInputs);
                return
            }

            let inputVector = [];

            if (['XOR', 'XNOR', 'XOR3', 'XNOR3'].includes(currentMode)) {
                inputVector = Array.from(document.querySelectorAll('.logic-sw')).map(sw => sw.checked ? 1 : 0);
            } else if (['SIN', 'COS'].includes(currentMode)) {
                inputVector = [parseFloat(document.querySelector('#dynamicTestUI input[type="range"]').value)];
            } else if (currentMode === 'MOON') {
                inputVector = [parseFloat(document.getElementById('moonX').value), parseFloat(document.getElementById('moonY').value)];
            } else if (currentMode === 'COLOR') {
                const hex = document.getElementById('colPick').value;
                const r = parseInt(hex.slice(1, 3), 16) / 255;
                const g = parseInt(hex.slice(3, 5), 16) / 255;
                const b = parseInt(hex.slice(5, 7), 16) / 255;
                inputVector = [r, g, b];
            }

            if (layers.length > 0) executeInference(inputVector);
        }

        function executeRangeInference(xValues, rangeInputs) {
            let currentA = rangeInputs;
            for (let L of layers) currentA = L.forward(currentA);

            // Rescale outputs back to -1 to 1 range for visualization
            const yValues = currentA.map(out => (out[0] * 2) - 1);

            const trace = {
                x: xValues,
                y: yValues,
                mode: 'lines',
                name: 'Model Range Prediction',
                line: { color: '#00ff41', width: 3 }
            };

            const layout = {
                paper_bgcolor: '#1a1a1a',
                plot_bgcolor: '#1a1a1a',
                font: { color: '#0f0' },
                margin: { t: 10, b: 30, l: 30, r: 10 },
                xaxis: { title: 'Input (rad)' },
                yaxis: { title: 'f(x)' }
            };

            Plotly.react('plot', [trace], layout);
            document.getElementById('mathResultDisplay').innerText = `Plotted ${xValues.length} points across range.`;
        }

        function executeInference(inputVector) {
            if (['SIN', 'COS'].includes(currentMode)) {
                inputVector = [inputVector[0] % (Math.PI * 2)];
            }
            let currentA = [inputVector];
            for (let L of layers) currentA = L.forward(currentA);
            const outputs = currentA[0];

            const resultDiv = document.getElementById('predictionResult');

            if (['XOR', 'XNOR', 'XOR3', 'XNOR3'].includes(currentMode)) {
                const val = outputs[0];
                document.getElementById('bulb').style.background = `rgba(0, 255, 65, ${val})`;
                document.getElementById('bulb').style.boxShadow = val > 0.5 ? `0 0 15px #00ff41` : 'none';
                document.getElementById('logicVal').innerText = val.toFixed(3);
                resultDiv.innerHTML = `Signal: ${(val * 100).toFixed(1)}%`;
            }
            else if (currentMode === 'MOON') {
                const val = outputs[0]; // Assuming 1 output neuron for binary
                const probB = val;
                const probA = 1 - val;

                // Update Orb A (Red - Class 0)
                document.getElementById('orbA').style.background = `rgba(255, 49, 49, ${probA})`;
                document.getElementById('orbA').style.boxShadow = probA > 0.5 ? `0 0 15px #ff3131` : 'none';

                // Update Orb B (Green - Class 1)
                document.getElementById('orbB').style.background = `rgba(0, 255, 65, ${probB})`;
                document.getElementById('orbB').style.boxShadow = probB > 0.5 ? `0 0 15px #00ff41` : 'none';

                resultDiv.innerHTML = `Classification: ${val > 0.5 ? 'Moon B' : 'Moon A'} (${(val * 100).toFixed(1)}%)`;
            }
            else if (['SIN', 'COS'].includes(currentMode)) {
                const rawVal = outputs[0];
                const finalVal = (rawVal * 2) - 1;
                document.getElementById('mathResultDisplay').innerText = `f(x) ≈ ${finalVal.toFixed(4)}`;
                resultDiv.innerHTML = `Regression Output: ${rawVal.toFixed(4)}`;
            }
            else {
                displayOutputResults(outputs); // Handles Color
            }
        }

        function displayOutputResults(outputs) {
            let html = `<div style="color: #fff; margin-top:10px;">Network Output:</div>`;
            outputs.forEach((val, i) => {
                html += `
        <div style="margin-bottom: 4px;">
            <span style="font-size:0.7rem">${i === 0 ? 'WARM' : i === 1 ? 'NEUTRAL' : 'COOL'}: ${(val * 100).toFixed(1)}%</span>
            <div style="background: #333; width: 100%; height: 8px;">
                <div style="background: var(--neon); width: ${val * 100}%; height: 100%;"></div>
            </div>
        </div>`;
            });
            document.getElementById('predictionResult').innerHTML = html;
        }

        // --- DATASET GENERATORS ---
        function setDataset(type, btnElement) {
            // 1. UI Highlight Logic
            document.querySelectorAll('.btn-group button').forEach(btn => btn.classList.remove('active-dataset'));
            if (btnElement) btnElement.classList.add('active-dataset');

            // 2. Clear previous inference/results
            document.getElementById('predictionResult').innerHTML = "Result: awaiting input...";
            lossHistory = []; // Reset loss history for the new dataset

            // 3. Dataset Definitions
            if (type === 'XOR') {
                document.getElementById('inputX').value = "0,0; 0,1; 1,0; 1,1";
                document.getElementById('inputY').value = "0; 1; 1; 0";
            } else if (type === 'XNOR') {
                document.getElementById('inputX').value = "0,0; 0,1; 1,0; 1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1";
            } else if (type === 'XOR3') {
                document.getElementById('inputX').value = "0,0,0; 0,0,1; 0,1,0; 0,1,1; 1,0,0; 1,0,1; 1,1,0; 1,1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1; 0; 1; 1; 0";
            } else if (type === 'XNOR3') {
                document.getElementById('inputX').value = "0,0,0; 0,0,1; 0,1,0; 0,1,1; 1,0,0; 1,0,1; 1,1,0; 1,1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1; 0; 1; 1; 0";
            } else if (type === 'COS') {
                let x = [], y = [];
                for (let i = 0; i <= 20; i++) { x.push(i / 5); y.push((Math.cos(i / 5 * Math.PI) + 1) / 2); }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            } else if (type === 'SIN') {
                let x = [], y = [];
                for (let i = 0; i <= 20; i++) { x.push(i / 5); y.push((Math.sin(i / 5 * Math.PI) + 1) / 2); }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            } else if (type === 'MOON') {
                let x = [], y = [];
                for (let i = 0; i < 40; i++) {
                    let p = (i / 40) * Math.PI;
                    x.push(`${Math.cos(p).toFixed(2)},${Math.sin(p).toFixed(2)}`); y.push(0);
                    x.push(`${(1 - Math.cos(p)).toFixed(2)},${(0.5 - Math.sin(p)).toFixed(2)}`); y.push(1);
                }
                document.getElementById('inputX').value = x.join('; ');
                document.getElementById('inputY').value = y.join('; ');
            }

            updateTestUI(type);
            buildNetwork();
        }

        function addLayerUI() {
            const div = document.createElement('div');
            div.style = "display:flex; gap:2px; margin-top:2px;";
            div.innerHTML = `<input type="number" class="l-size" value="4"> <select class="l-act"><option value="tanh">Tanh</option><option value="relu">ReLU</option><option value="lrelu">Leaky ReLU</option></select> <button onclick="this.parentElement.remove()" style="width:30px">x</button>`;
            document.getElementById('layersConfig').appendChild(div);
        }

        function buildNetwork() {
            const xRaw = document.getElementById('inputX').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
            const yRaw = document.getElementById('inputY').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));

            layers = [];
            let curIn = xRaw[0].length;

            // Build Hidden Layers
            document.querySelectorAll('#layersConfig > div:not([style*="border-top"])').forEach(el => {
                let sInput = el.querySelector('.l-size');
                if (!sInput) return; // Skip the output config div
                let s = parseInt(sInput.value);
                let a = el.querySelector('.l-act').value;
                layers.push(new Layer(curIn, s, a));
                curIn = s;
            });

            // NEW: Build Output Layer based on User Choice
            const outputDim = yRaw[0].length;
            const finalAct = document.getElementById('outputAct').value;
            layers.push(new Layer(curIn, outputDim, finalAct));

            renderWeights();
            drawNet();
            document.getElementById('status').innerText = "Status: Network Built. Ready to Train.";
        }


        function predictUniversal() {
            if (layers.length === 0) {
                document.getElementById('predictionResult').innerText = "Error: Build and train the network first.";
                return;
            }

            // 1. Parse the input string
            const inputStr = document.getElementById('testInput').value;
            const inputVector = inputStr.split(',').map(v => parseFloat(v.trim()));

            // Validation: Ensure input length matches the first layer's weights
            if (inputVector.length !== layers[0].w.length) {
                document.getElementById('predictionResult').innerText =
                    `Error: Expected ${layers[0].w.length} inputs, but got ${inputVector.length}.`;
                return;
            }

            // 2. Forward Pass: Pass the input through all layers
            let currentA = [inputVector];
            for (let L of layers) {
                currentA = L.forward(currentA);
            }

            // 3. Display Results
            const outputs = currentA[0];
            let html = `<div style="color: #fff; margin-bottom: 5px;">Output Activations:</div>`;

            outputs.forEach((val, i) => {
                const percentage = (val * 100).toFixed(2);
                // Create a simple visual bar for each output
                html += `
            <div style="margin-bottom: 4px;">
                <span style="display:inline-block; width: 80px;">Out[${i}]:</span>
                <span style="color: #00ff41;">${percentage}%</span>
                <div style="background: #333; width: 100%; height: 4px; margin-top: 2px;">
                    <div style="background: #00ff41; width: ${val * 100}%; height: 100%;"></div>
                </div>
            </div>`;
            });

            // For classification: Highlight the winner
            const maxIdx = outputs.indexOf(Math.max(...outputs));
            html += `<div style="margin-top: 8px; border-top: 1px solid #444; padding-top: 5px;">
                Primary Class: <strong style="color:#00ff41;">Index ${maxIdx}</strong>
             </div>`;

            document.getElementById('predictionResult').innerHTML = html;
        }

        function setColorDataset(btnElement) {
            if (btnElement) btnElement.classList.add('active-dataset');
            const data = [
                // --- WARM COLORS (Output: 1,0,0) ---
                // Characteristics: High Red, Low Blue
                { x: "1,0,0", y: "1,0,0" },       // Pure Red
                { x: "1,0.5,0", y: "1,0,0" },     // Orange
                { x: "1,1,0", y: "1,0,0" },       // Yellow
                { x: "0.8,0.2,0.1", y: "1,0,0" }, // Brick Red
                { x: "0.6,0,0", y: "1,0,0" },     // Deep Maroon
                { x: "1,0.3,0.3", y: "1,0,0" },   // Coral/Pink
                { x: "0.9,0.4,0.1", y: "1,0,0" }, // Burnt Orange
                { x: "0.5,0.2,0", y: "1,0,0" },   // Brown

                // --- COOL COLORS (Output: 0,1,0) ---
                // Characteristics: High Blue or Green, Low Red
                { x: "0,0,1", y: "0,1,0" },       // Pure Blue
                { x: "0,1,0", y: "0,1,0" },       // Pure Green
                { x: "0,1,1", y: "0,1,0" },       // Cyan
                { x: "0.5,0,1", y: "0,1,0" },     // Purple (Moved to Cool)
                { x: "0.2,0.2,0.8", y: "0,1,0" }, // Soft Blue
                { x: "0,0.5,0.5", y: "0,1,0" },   // Teal
                { x: "0.1,0.8,0.2", y: "0,1,0" }, // Bright Green
                { x: "0.7,0.3,1", y: "0,1,0" },   // Violet

                // --- NEUTRAL/MUTED (Output: 0,0,1) ---
                // Characteristics: R, G, and B are nearly equal
                { x: "0,0,0", y: "0,0,1" },       // Black
                { x: "1,1,1", y: "0,0,1" },       // White
                { x: "0.5,0.5,0.5", y: "0,0,1" }, // Mid Gray
                { x: "0.2,0.2,0.2", y: "0,0,1" }, // Dark Gray
                { x: "0.8,0.8,0.8", y: "0,0,1" }, // Light Gray
                { x: "0.4,0.4,0.4", y: "0,0,1" }, // Charcoal
                { x: "0.6,0.6,0.6", y: "0,0,1" }, // Silver
                { x: "0.1,0.1,0.1", y: "0,0,1" }  // Near Black
            ];

            document.getElementById('inputX').value = data.map(d => d.x).join('; ');
            document.getElementById('inputY').value = data.map(d => d.y).join('; ');

            updateTestUI('COLOR');
            buildNetwork();

        }

        async function toggleTraining() {
            if (isTraining) return;
            if (layers.length === 0) buildNetwork();

            isTraining = true; stopFlag = false;
            document.getElementById('trainBtn').innerText = "TRAINING...";

            const xRaw = document.getElementById('inputX').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
            const yRaw = document.getElementById('inputY').value.split(';').map(r => r.split(',').filter(v => v.trim() !== "").map(v => parseFloat(v.trim())));

            const maxEpochs = parseInt(document.getElementById('epochs').value);
            const delay = parseInt(document.getElementById('delay').value);
            const lr = parseFloat(document.getElementById('lr').value);

            lossHistory = [];
            for (let ep = 0; ep <= maxEpochs; ep++) {
                while (isPaused) await new Promise(r => setTimeout(r, 100));
                if (stopFlag) break;

                // Forward
                let acts = [xRaw];
                for (let L of layers) acts.push(L.forward(acts[acts.length - 1]));

                // Backward
                let out = acts[acts.length - 1];
                let error = out.map((row, i) => row.map((v, j) => v - yRaw[i][j]));
                let mse = error.flat().reduce((a, b) => a + b * b, 0) / xRaw.length;
                lossHistory.push(mse);

                let dZ = error.map((row, i) => row.map((err, j) => err * (2 / xRaw.length) * Act[layers[layers.length - 1].act].df(layers[layers.length - 1].lastZ[i][j])));

                for (let i = layers.length - 1; i >= 0; i--) {
                    let L = layers[i], prevA = acts[i];
                    let dW = L.w.map((row, rI) => row.map((_, cI) => dZ.reduce((s, dzR, rI2) => s + dzR[cI] * prevA[rI2][rI], 0)));
                    let dB = dZ[0].map((_, cI) => dZ.reduce((s, dzR) => s + dzR[cI], 0));

                    if (i > 0) {
                        let prevL = layers[i - 1];
                        dZ = dZ.map((dzR, rI) => prevL.w[0].map((_, cI) => {
                            let da = dzR.reduce((s, dzV, curCI) => s + dzV * L.w[cI][curCI], 0);
                            return da * Act[prevL.act].df(prevL.lastZ[rI][cI]);
                        }));
                    }
                    L.w = L.w.map((row, r) => row.map((v, c) => v - lr * dW[r][c]));
                    L.b = L.b.map((v, c) => v - lr * dB[c]);
                }

                if (ep % 20 === 0) {
                    updateViz(xRaw, yRaw, out, mse, ep);
                    renderWeights();
                    await new Promise(r => setTimeout(r, delay));
                }
            }
            isTraining = false;
            document.getElementById('trainBtn').innerText = "START TRAINING";
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').innerText = isPaused ? "RESUME" : "PAUSE";
        }

        function updateViz(x, y, preds, loss, ep) {
            document.getElementById('status').innerText = `Epoch: ${ep} | Loss: ${loss.toFixed(4)}`;
            const inDim = x[0].length;
            const outDim = y[0].length;
            let traces = [];
            let layout = {
                paper_bgcolor: '#1a1a1a', plot_bgcolor: '#1a1a1a',
                font: { color: '#0f0' }, margin: { t: 0, b: 0, l: 0, r: 0 },
                xaxis: { gridcolor: '#222' }, yaxis: { gridcolor: '#222' }
            };

            if (inDim === 1) {
                // --- 1D REGRESSION (SIN/COS) ---
                traces.push({ x: x.map(r => r[0]), y: y.map(r => r[0]), mode: 'markers', name: 'Target' });
                traces.push({ x: x.map(r => r[0]), y: preds.map(r => r[0]), mode: 'lines', name: 'Network' });
            }
            else if (inDim === 2) {
                // --- 2D CLASSIFICATION (XOR/MOONS) ---
                const isXOR = currentMode.includes('XOR');
                const rangeLimit = isXOR ? 1.1 : 1.5; // Tighter view for XOR, wider for Moons
                const rangeStart = isXOR ? -0.1 : -0.7;

                // 1. Update Layout for Ticks and Visibility
                layout.margin = { t: 20, b: 40, l: 50, r: 20 }; // Increased margin for tick labels

                layout.xaxis = {
                    title: { text: "Input X", font: { size: 10 } },
                    range: [rangeStart, rangeLimit],
                    gridcolor: '#222',
                    showticklabels: true,
                    tickfont: { color: '#00ff41', size: 10 },
                    tickmode: 'auto',
                    nticks: 10,
                    zeroline: true,
                    zerolinecolor: '#444'
                };
                layout.yaxis = {
                    title: { text: "Input Y", font: { size: 10 } },
                    range: [rangeStart, rangeLimit],
                    gridcolor: '#222',
                    showticklabels: true,
                    tickfont: { color: '#00ff41', size: 10 },
                    tickmode: 'auto',
                    nticks: 10,
                    zeroline: true,
                    zerolinecolor: '#444'
                };

                // 2. Generate Heatmap Grid
                const resolution = 30;
                let gridX = [], gridY = [], gridZ = [];

                for (let i = 0; i <= resolution; i++) {
                    gridX.push(rangeStart + (i / resolution) * (rangeLimit - rangeStart));
                    gridY.push(rangeStart + (i / resolution) * (rangeLimit - rangeStart));
                }

                for (let j = 0; j <= resolution; j++) {
                    let py = gridY[j];
                    let rowZ = [];
                    for (let i = 0; i <= resolution; i++) {
                        let px = gridX[i];

                        // Forward pass
                        let out = [px, py];
                        for (let L of layers) out = L.forward([out])[0];

                        // Push prediction
                        rowZ.push(outDim === 3 ? out[0] - out[1] : out[0]);
                    }
                    gridZ.push(rowZ); // Now gridZ[j][i] matches [Y][X]
                }



                traces.push({
                    x: gridX,
                    y: gridY,
                    z: gridZ,
                    type: 'heatmap',
                    transpose: false,
                    colorscale: 'RdBu', // Blue/Red is standard for binary classification
                    reversescale: true,
                    opacity: 0.4,
                    showscale: false,
                    hoverinfo: 'skip'
                });

                // 3. Add Data Points
                traces.push({
                    x: x.map(r => r[0]), y: x.map(r => r[1]),
                    mode: 'markers',
                    marker: {
                        color: y.map(r => r[0] > 0.5 ? '#00ff41' : '#ff3131'),
                        size: 9,
                        line: { color: '#fff', width: 1 }
                    },
                    name: 'Data'
                });
            } else if (inDim === 3) {
                // --- 3D CLASSIFICATION (XOR3/COLOR) ---
                // 1. Data Points
                traces.push({
                    x: x.map(r => r[0]), y: x.map(r => r[1]), z: x.map(r => r[2]),
                    type: 'scatter3d', mode: 'markers',
                    marker: {
                        color: currentMode === 'COLOR' ? x.map(r => `rgb(${r[0] * 255},${r[1] * 255},${r[2] * 255})`) : y.map(r => r[0] > 0.5 ? '#00ff41' : '#ff3131'),
                        size: 5, symbol: 'circle', line: { color: '#fff', width: 1 }
                    }
                });

                // 2. Decision Boundary (Slice Plane at Z=0.5)
                let sliceX = [], sliceY = [], sliceZ = [];
                for (let i = 0; i <= 10; i++) {
                    let rowX = [], rowY = [], rowZ = [];
                    for (let j = 0; j <= 10; j++) {
                        let px = i / 10, py = j / 10, pz = 0.5;
                        let out = [px, py, pz];
                        for (let L of layers) out = L.forward([out])[0];
                        rowX.push(px); rowY.push(py); rowZ.push(out[0]);
                    }
                    sliceX.push(rowX); sliceY.push(rowY); sliceZ.push(rowZ);
                }
                // This adds a translucent "prediction sheet" inside the 3D cube
                traces.push({
                    x: sliceX, y: sliceY, z: sliceZ,
                    type: 'surface', opacity: 0.3, showscale: false, colorscale: 'Greens'
                });

                layout.scene = {
                    xaxis: { title: 'R / In1', backgroundcolor: "#000", gridcolor: "#333" },
                    yaxis: { title: 'G / In2', backgroundcolor: "#000", gridcolor: "#333" },
                    zaxis: { title: 'B / In3', backgroundcolor: "#000", gridcolor: "#333" },
                    aspectmode: 'cube'
                };
            }

            Plotly.react('plot', traces, layout);
            Plotly.react('lossPlot', [{ y: lossHistory, type: 'scatter', line: { color: 'red' } }],
                { ...layout, margin: { t: 10, b: 30, l: 30, r: 10 }, yaxis: { type: 'log' } });

            // This ensures the neuron/weight drawing still happens!
            drawNet();
        }

        function renderWeights() {
            let html = "";
            layers.forEach((L, i) => {
                // Create a container for each layer's weights
                html += `<div class="matrix-table">
                    <div class="layer-title">Layer ${i} → ${i + 1} (${L.act})</div>
                    <table>`;

                // Rows = Input Neurons, Cols = Output Neurons
                L.w.forEach((row, rIdx) => {
                    html += "<tr>";
                    row.forEach(v => {
                        // Color coding: Green for positive, Red for negative
                        const color = isNaN(v) ? '#fbbf24' : v > 0 ? '#10b981' : '#f43f5e';
                        const opacity = Math.min(1, Math.abs(v));
                        html += `<td style="color:${color}; opacity:${0.3 + opacity}">${v.toFixed(4)}</td>`;
                    });
                    html += "</tr>";
                });

                html += `</table><div class="layer-title" style="background:#1e293b; padding:2px;">Biases</div><table style="width:100%"><tr>`;
                L.b.forEach(v => {
                    html += `<td>${v.toFixed(4)}</td>`;
                });
                html += "</tr></table></div>";
            });
            document.getElementById('matrixDisplay').innerHTML = html;
        }

        function drawNet() {
            const actColors = {
                input: '#ffffff',   // White for input
                relu: '#fbbf24',    // Amber
                tanh: '#8b5cf6',    // Purple
                sigmoid: '#ec4899', // Pink
                lrelu: '#f97316',   // Orange
                softmax: '#06b6d4', // Cyan
                linear: '#94a3b8'   // Slate
            };


            const canvas = document.getElementById('netCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            if (layers.length === 0) return;
            const counts = [layers[0].w.length, ...layers.map(l => l.w[0].length)];
            const xStep = canvas.width / (counts.length + 1);
            const pos = counts.map((c, i) => Array.from({ length: c }, (_, j) => ({ x: xStep * (i + 1), y: (canvas.height / (c + 1)) * (j + 1) })));

            layers.forEach((L, lIdx) => {
                L.w.forEach((row, i) => row.forEach((w, j) => {
                    ctx.beginPath(); ctx.moveTo(pos[lIdx][i].x, pos[lIdx][i].y); ctx.lineTo(pos[lIdx + 1][j].x, pos[lIdx + 1][j].y);
                    ctx.strokeStyle = isNaN(w) ? '#fbbf24' : w > 0 ? `rgba(16, 185, 129, ${Math.abs(w) * 0.4})` : `rgba(244, 63, 94, ${Math.abs(w) * 0.4})`;
                    ctx.lineWidth = Math.min(5, Math.abs(w) * 2); ctx.stroke();
                }));
            });

            pos.forEach((layerNodes, lIdx) => {
                // Determine color: first layer is 'input', others come from layers[lIdx-1]
                const actType = lIdx === 0 ? 'input' : layers[lIdx - 1].act;
                const nodeColor = actColors[actType] || '#ffffff';

                layerNodes.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, 7); // Slightly larger nodes
                    ctx.fillStyle = nodeColor;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = nodeColor; // Adds a subtle glow per activation type
                    ctx.fill();
                    ctx.shadowBlur = 0; // Reset shadow for next draw
                });
            });
        }
    </script>
</body>

</html>