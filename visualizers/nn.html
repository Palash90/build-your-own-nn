<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Advanced Neural Engine</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        :root {
            --neon: #00ff41;
            --bg: #0a0a0a;
            --panel: #1a1a1a;
        }

        body {
            font-family: 'Consolas', monospace;
            background: var(--bg);
            color: var(--neon);
            padding: 20px;
            margin: 0;
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            max-width: 1600px;
            margin: auto;
        }

        .panel {
            background: var(--panel);
            border: 1px solid #333;
            padding: 15px;
            border-radius: 8px;
            overflow: hidden;
        }

        .controls {
            grid-column: span 2;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            background: #111;
            padding: 20px;
            border: 1px solid var(--neon);
        }

        canvas {
            background: #000;
            width: 100%;
            height: 250px;
            border: 1px solid #222;
            margin-top: 10px;
        }

        input,
        select,
        button {
            background: #000;
            color: var(--neon);
            border: 1px solid var(--neon);
            padding: 8px;
            width: 100%;
            margin-top: 5px;
            cursor: pointer;
        }

        button:hover {
            background: #003311;
        }

        /* Weight Grid Styling */
        #weightInspector {
            grid-column: span 2;
            max-height: 300px;
            overflow-y: auto;
            font-size: 0.75rem;
        }

        .matrix-table {
            border-collapse: collapse;
            margin: 10px;
            display: inline-block;
            vertical-align: top;
            border: 1px solid #444;
        }

        .matrix-table td {
            border: 1px solid #333;
            padding: 4px;
            text-align: center;
            min-width: 60px;
        }

        .layer-title {
            color: #fff;
            text-transform: uppercase;
            font-size: 0.8rem;
            border-bottom: 1px solid var(--neon);
            margin-bottom: 5px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
        }

        label {
            font-size: 0.7rem;
            color: #888;
            text-transform: uppercase;
        }
    </style>
</head>

<body>

    <h2 style="text-align: center;">NEURAL ARCHITECT & TRACE ENGINE</h2>

    <div class="dashboard">
        <div class="panel"><label>Prediction Plot</label>
            <div id="plot" style="height: 350px;"></div>
        </div>
        <div class="panel"><label>Loss History</label>
            <div id="lossPlot" style="height: 350px;"></div>
        </div>

        <div class="panel" style="grid-column: span 2;">
            <label>Topology & Weight Magnitude (Live)</label>
            <canvas id="netCanvas"></canvas>
            <div id="status" style="margin-top:10px;">Status: Awaiting Initialization</div>
        </div>

        <div id="weightInspector" class="panel">
            <label>Numerical Weight & Bias Matrices (Trace)</label>
            <div id="matrixDisplay"></div>
        </div>

        <div class="controls">
            <div>
                <label>Data Management</label>
                <input id="inputX" value="0,0; 0,1; 1,0; 1,1">
                <input id="inputY" value="1; 0; 0; 1">
                <div class="btn-group">
                    <button onclick="setDataset('XOR')">XOR</button>
                    <button onclick="setDataset('XNOR')">XNOR</button>
                    <button onclick="setDataset('SIN')">SIN</button>
                    <button onclick="setDataset('COS')">COS</button>
                    <button onclick="setDataset('MOON')">MOONS</button>
                </div>
            </div>

            <div>
                <label>Network Structure</label>
                <div id="layersConfig">
                    <div style="display:flex; gap:2px">
                        <input type="number" class="l-size" value="4">
                        <select class="l-act">
                            <option value="tanh">Tanh</option>
                            <option value="relu">ReLU</option>
                        </select>
                    </div>
                </div>
                <button onclick="addLayerUI()">+ ADD LAYER</button>
                <button onclick="buildNetwork()" style="background: #222;">BUILD NETWORK</button>
            </div>

            <div>
                <label>Training Parameters</label>
                <div style="display:flex; gap:5px">
                    <div style="flex:1"><label>Epochs</label><input type="number" id="epochs" value="2000"></div>
                    <div style="flex:1"><label>Delay(ms)</label><input type="number" id="delay" value="10"></div>
                </div>
                <label>Learning Rate</label>
                <input type="number" id="lr" value="0.1" step="0.01">
            </div>

            <div>
                <label>Execution</label>
                <select id="plotMode">
                    <option value="auto">Auto (Adaptive)</option>
                    <option value="pca">Force PCA</option>
                    <option value="2d">Force 2D</option>
                </select>
                <button id="trainBtn" onclick="toggleTraining()"
                    style="background:#00441b; font-size: 1.1rem; height: 60px;">START TRAINING</button>
                <div class="btn-group">
                    <button onclick="stopFlag=true" style="background:#440000">STOP</button>
                    <button id="pauseBtn" onclick="togglePause()">PAUSE</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let layers = [], isTraining = false, isPaused = false, stopFlag = false, lossHistory = [];

        const Act = {
            relu: { f: x => Math.max(0, x), df: x => x > 0 ? 1 : 0 },
            tanh: { f: x => Math.tanh(x), df: x => 1 - Math.pow(Math.tanh(x), 2) },
            sigmoid: { f: x => 1 / (1 + Math.exp(-x)), df: x => { let s = 1 / (1 + Math.exp(-x)); return s * (1 - s); } }
        };

        class Layer {
            constructor(inD, outD, act) {
                this.act = act;
                let s = Math.sqrt(2 / (inD + outD)); // Xavier Init
                this.w = Array.from({ length: inD }, () => Array.from({ length: outD }, () => (Math.random() * 2 - 1) * s));
                this.b = new Array(outD).fill(0);
                this.lastZ = []; this.lastA = [];
            }
            forward(X) {
                this.lastZ = X.map(row => this.b.map((b, j) => row.reduce((sum, v, i) => sum + v * this.w[i][j], 0) + b));
                this.lastA = this.lastZ.map(row => row.map(v => Act[this.act].f(v)));
                return this.lastA;
            }
        }

        // --- DATASET GENERATORS ---
        function setDataset(type) {
            if (type === 'XOR') {
                document.getElementById('inputX').value = "0,0; 0,1; 1,0; 1,1";
                document.getElementById('inputY').value = "0; 1; 1; 0";
            } else if (type === 'XNOR') {
                document.getElementById('inputX').value = "0,0; 0,1; 1,0; 1,1";
                document.getElementById('inputY').value = "1; 0; 0; 1";
            } else if (type === 'COS') {
                let x = [], y = [];
                for (let i = 0; i <= 20; i++) { x.push(i / 5); y.push((Math.cos(i / 5 * Math.PI) + 1) / 2); }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            } else if (type === 'SIN') {
                let x = [], y = [];
                for (let i = 0; i <= 20; i++) { x.push(i / 5); y.push((Math.sin(i / 5 * Math.PI) + 1) / 2); }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            } else if (type === 'MOON') {
                let x = [], y = [];
                for (let i = 0; i < 30; i++) {
                    let p = (i / 30) * Math.PI;
                    x.push(`${Math.cos(p).toFixed(2)},${Math.sin(p).toFixed(2)}`); y.push(0);
                    x.push(`${(1 - Math.cos(p)).toFixed(2)},${(0.5 - Math.sin(p)).toFixed(2)}`); y.push(1);
                }
                document.getElementById('inputX').value = x.join('; '); document.getElementById('inputY').value = y.join('; ');
            }
            buildNetwork();
        }

        function addLayerUI() {
            const div = document.createElement('div');
            div.style = "display:flex; gap:2px; margin-top:2px;";
            div.innerHTML = `<input type="number" class="l-size" value="4"> <select class="l-act"><option value="tanh">Tanh</option><option value="relu">ReLU</option></select> <button onclick="this.parentElement.remove()" style="width:30px">x</button>`;
            document.getElementById('layersConfig').appendChild(div);
        }

        function buildNetwork() {
            const xRaw = document.getElementById('inputX').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
            const yRaw = document.getElementById('inputY').value.split(';').map(r => [parseFloat(r.trim())]);
            layers = [];
            let curIn = xRaw[0].length;
            document.querySelectorAll('#layersConfig > div').forEach(el => {
                let s = parseInt(el.querySelector('.l-size').value);
                let a = el.querySelector('.l-act').value;
                layers.push(new Layer(curIn, s, a));
                curIn = s;
            });
            layers.push(new Layer(curIn, yRaw[0].length, 'sigmoid')); // Final layer logic
            renderWeights();
            drawNet();
            document.getElementById('status').innerText = "Status: Network Built. Ready to Train.";
        }

        async function toggleTraining() {
            if (isTraining) return;
            if (layers.length === 0) buildNetwork();

            isTraining = true; stopFlag = false;
            document.getElementById('trainBtn').innerText = "TRAINING...";

            const xRaw = document.getElementById('inputX').value.split(';').map(r => r.split(',').map(v => parseFloat(v.trim())));
            const yRaw = document.getElementById('inputY').value.split(';').map(r => [parseFloat(r.trim())]);
            const maxEpochs = parseInt(document.getElementById('epochs').value);
            const delay = parseInt(document.getElementById('delay').value);
            const lr = parseFloat(document.getElementById('lr').value);

            lossHistory = [];
            for (let ep = 0; ep <= maxEpochs; ep++) {
                while (isPaused) await new Promise(r => setTimeout(r, 100));
                if (stopFlag) break;

                // Forward
                let acts = [xRaw];
                for (let L of layers) acts.push(L.forward(acts[acts.length - 1]));

                // Backward
                let out = acts[acts.length - 1];
                let error = out.map((row, i) => row.map((v, j) => v - yRaw[i][j]));
                let mse = error.flat().reduce((a, b) => a + b * b, 0) / xRaw.length;
                lossHistory.push(mse);

                let dZ = error.map((row, i) => row.map((err, j) => err * (2 / xRaw.length) * Act[layers[layers.length - 1].act].df(layers[layers.length - 1].lastZ[i][j])));

                for (let i = layers.length - 1; i >= 0; i--) {
                    let L = layers[i], prevA = acts[i];
                    let dW = L.w.map((row, rI) => row.map((_, cI) => dZ.reduce((s, dzR, rI2) => s + dzR[cI] * prevA[rI2][rI], 0)));
                    let dB = dZ[0].map((_, cI) => dZ.reduce((s, dzR) => s + dzR[cI], 0));

                    if (i > 0) {
                        let prevL = layers[i - 1];
                        dZ = dZ.map((dzR, rI) => prevL.w[0].map((_, cI) => {
                            let da = dzR.reduce((s, dzV, curCI) => s + dzV * L.w[cI][curCI], 0);
                            return da * Act[prevL.act].df(prevL.lastZ[rI][cI]);
                        }));
                    }
                    L.w = L.w.map((row, r) => row.map((v, c) => v - lr * dW[r][c]));
                    L.b = L.b.map((v, c) => v - lr * dB[c]);
                }

                if (ep % 20 === 0) {
                    updateViz(xRaw, yRaw, out, mse, ep);
                    renderWeights();
                    await new Promise(r => setTimeout(r, delay));
                }
            }
            isTraining = false;
            document.getElementById('trainBtn').innerText = "START TRAINING";
        }

        function togglePause() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').innerText = isPaused ? "RESUME" : "PAUSE";
        }

        function updateViz(x, y, preds, loss, ep) {
            document.getElementById('status').innerText = `Epoch: ${ep} | Loss: ${loss.toFixed(4)}`;
            const mode = document.getElementById('plotMode').value;
            const dim = x[0].length;
            let traces = [{ x: x.map(r => r[0]), y: y.map(r => r[0]), mode: 'markers', name: 'Actual', marker: { color: '#0f0' } }];
            let layout = { paper_bgcolor: '#1a1a1a', plot_bgcolor: '#1a1a1a', font: { color: '#0f0' }, margin: { t: 10, b: 30, l: 30, r: 10 } };

            if (mode === '2d' || (mode === 'auto' && dim === 1)) {
                traces.push({ x: x.map(r => r[0]), y: preds.map(r => r[0]), mode: 'lines+markers', name: 'Model', line: { color: '#f0f' } });
            } else {
                traces = [
                    { x: x.map(r => r[0]), y: x.map(r => r[1]), z: y.map(r => r[0]), type: 'scatter3d', mode: 'markers', name: 'Actual' },
                    { x: x.map(r => r[0]), y: x.map(r => r[1]), z: preds.map(r => r[0]), type: 'scatter3d', mode: 'markers', name: 'Model', marker: { color: '#f0f', size: 4 } }
                ];
            }
            Plotly.react('plot', traces, layout);
            Plotly.react('lossPlot', [{ y: lossHistory, type: 'scatter', line: { color: 'red' } }], { ...layout, yaxis: { type: 'log' } });
            drawNet();
        }

        function renderWeights() {
            let html = "";
            layers.forEach((L, i) => {
                // Create a container for each layer's weights
                html += `<div class="matrix-table">
                    <div class="layer-title">Layer ${i} â†’ ${i + 1} (${L.act})</div>
                    <table>`;

                // Rows = Input Neurons, Cols = Output Neurons
                L.w.forEach((row, rIdx) => {
                    html += "<tr>";
                    row.forEach(v => {
                        // Color coding: Green for positive, Red for negative
                        const color = v > 0 ? '#00ff41' : '#ff3131';
                        const opacity = Math.min(1, Math.abs(v));
                        html += `<td style="color:${color}; opacity:${0.3 + opacity}">${v.toFixed(4)}</td>`;
                    });
                    html += "</tr>";
                });

                html += `</table><div class="layer-title">Biases</div><table><tr>`;
                L.b.forEach(v => {
                    html += `<td>${v.toFixed(4)}</td>`;
                });
                html += "</tr></table></div>";
            });
            document.getElementById('matrixDisplay').innerHTML = html;
        }

        function drawNet() {
            const canvas = document.getElementById('netCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth; canvas.height = canvas.offsetHeight;
            if (layers.length === 0) return;
            const counts = [layers[0].w.length, ...layers.map(l => l.w[0].length)];
            const xStep = canvas.width / (counts.length + 1);
            const pos = counts.map((c, i) => Array.from({ length: c }, (_, j) => ({ x: xStep * (i + 1), y: (canvas.height / (c + 1)) * (j + 1) })));

            layers.forEach((L, lIdx) => {
                L.w.forEach((row, i) => row.forEach((w, j) => {
                    ctx.beginPath(); ctx.moveTo(pos[lIdx][i].x, pos[lIdx][i].y); ctx.lineTo(pos[lIdx + 1][j].x, pos[lIdx + 1][j].y);
                    ctx.strokeStyle = w > 0 ? `rgba(0,255,65,${Math.abs(w)})` : `rgba(255,0,0,${Math.abs(w)})`;
                    ctx.lineWidth = Math.min(5, Math.abs(w) * 2); ctx.stroke();
                }));
            });
            pos.flat().forEach(p => { ctx.beginPath(); ctx.arc(p.x, p.y, 4, 0, 7); ctx.fillStyle = "#00ff41"; ctx.fill(); });
        }
    </script>
</body>

</html>